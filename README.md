---



\# cpp-preprocessor2



Учебный проект: \*\*свой препроцессор C++\*\*  

(раскрытие `#include`) с использованием:



\- `std::regex`

\- сырых строковых литералов (`R"( ... )"`)

\- рекурсии

\- `std::filesystem`



Проект демонстрирует прохождение тестов и \*\*реальное использование препроцессора в цепочке сборки\*\*.



---



\## Идея проекта



Мы пишем \*\*собственный препроцессор\*\*, а затем используем его:



\- чтобы \*\*склеить исходники другой версии проекта\*\* в один `.cpp`,

\- скомпилировать этот файл,

\- и запустить тесты.



То есть препроцессор \*\*работает на практике\*\*.



---



\## Кратко о версиях



\- \*\*V0\*\* — оркестратор (launcher):

&nbsp; - компилирует V1,

&nbsp; - запускает тесты V1,

&nbsp; - запускает V1 в режиме `--flatten`,

&nbsp; - компилирует результат в V2,

&nbsp; - запускает тесты V2.



\- \*\*V1\*\* — минимальная реализация препроцессора по ТЗ  

&nbsp; + режим `--flatten` (склейка проекта в один `.cpp`).



\- \*\*V2\*\* — улучшенная версия:

&nbsp; - убирает UTF-8 BOM,

&nbsp; - нормализует CRLF,

&nbsp; - нормализует пути,

&nbsp; - кэширует найденные include.



---



\## Итоговая цепочка работы (что реально происходит)



```



V0

├─ компилирует V1

├─ запускает V1 (тесты)

├─ запускает V1 --flatten

│     └─ получает build/v2\_flat.cpp

├─ компилирует build/v2\_flat.cpp → v2.exe

└─ запускает v2.exe (тесты)



````



Главное:



\- `build/v2\_flat.cpp` создаётся \*\*препроцессором V1\*\*.

\- Это делается \*\*рекурсией + regex\*\*, ровно теми же приёмами,

&nbsp; которые изучались в уроке.

\- В сборочной цепочке используется \*\*режим `--flatten`\*\*.



---



\## Ограничение склейки include (ВАЖНО)



В режиме `--flatten` препроцессор раскрывает \*\*ТОЛЬКО\*\* директивы вида:



```cpp

\#include "..."

````



Директивы вида:



```cpp

\#include <...>

```



\*\*НЕ раскрываются\*\* и копируются в выходной файл без изменений.



\### Почему так сделано



\* системные заголовки (`<iostream>`, `<vector>` и т.д.)

&nbsp; должны обрабатываться \*\*настоящим компилятором\*\* (`g++`);

\* поиск и раскрытие системных include \*\*не входит в задание\*\*;

\* это соответствует реальной практике склейки пользовательского кода:



&nbsp; \* \*\*unity build\*\* — компиляция проекта как одного большого файла

&nbsp;   (часто для ускорения сборки);

&nbsp; \* \*\*amalgamation\*\* — распространение проекта в виде одного `.cpp`

&nbsp;   (классический пример — SQLite).



Итог:



> препроцессор склеивает пользовательский код,

> компилятор обрабатывает стандартную библиотеку.



---



\## Структура проекта



```

cpp-preprocessor2/

│

├─ README.md

├─ v0.cpp                     # Оркестратор: V1 → flatten → V2

│

├─ v1\_parts/

│   ├─ v1\_main.cpp            # main() V1: тесты и режим --flatten

│   └─ v1\_preprocess\_impl.h

│       ├─ Preprocess                 # режим ТЗ

│       ├─ PreprocessOne\_TZ           # рекурсия для ТЗ

│       ├─ FlattenProject             # режим --flatten

│       └─ PreprocessOne\_Flatten      # рекурсивная склейка "..."

│

├─ v2\_parts/

│   ├─ v2\_main.cpp            # main() V2: тесты

│   └─ v2\_preprocess\_impl.h  # улучшенная реализация

│

├─ common/

│   └─ tests\_common.h         # общие тесты (используются V1 и V2)

│

└─ build/

&nbsp;   └─ v2\_flat.cpp            # GENERATED: результат --flatten (создаётся V1)

```



---



\## Ключевые функции (кто что делает)



\### V1



\* `v1::Preprocess(...)`

&nbsp; Реализация по ТЗ: раскрывает `"..."` и `<...>` по правилам задания.



\* `v1::PreprocessOne\_TZ(...)`

&nbsp; Рекурсивная функция:

&nbsp; читает файл построчно, заменяет `#include` вставкой содержимого.



\* `v1::FlattenProject(...)`

&nbsp; Делает “склейку” проекта в один `.cpp`

&nbsp; (используется в сборке V2).



\* `v1::PreprocessOne\_Flatten(...)`

&nbsp; Главная функция склейки:



&nbsp; \* рекурсивно раскрывает `#include "..."`,

&nbsp; \* \*\*НЕ раскрывает\*\* `#include <...>`,

&nbsp; \* игнорирует `#pragma once`,

&nbsp; \* формирует `build/v2\_flat.cpp`.



\### V2



\* улучшенная реализация препроцессора:



&nbsp; \* удаляет BOM,

&nbsp; \* убирает `\\r`,

&nbsp; \* нормализует пути,

&nbsp; \* кэширует найденные include,

&nbsp; \* проходит те же тесты.



---



\## Запуск (Windows / MinGW)



Чтобы русский текст корректно отображался в консоли:



```bat

chcp 65001

```



Далее:



```bat

set PATH=C:\\Qt\\Tools\\mingw1310\_64\\bin;%PATH%

g++ -std=gnu++17 v0.cpp -o v0.exe

v0.exe

```



---



\## Ожидаемый вывод (как в тренажёре)



Ключевые строки:



```bat

g++ -std=gnu++17 v1\_parts/v1\_main.cpp -o v1.exe

v1.exe

V1: минимальная реализация + flatten (только #include "...")

Анализируем и компилируем решение...

Запускаем тесты...

Успех!

v1.exe --flatten v2\_parts/v2\_main.cpp build/v2\_flat.cpp v2\_parts common

g++ -std=gnu++17 build/v2\_flat.cpp -o v2.exe

v2.exe

V2: улучшенная версия (BOM/CRLF/normalize/кэш) + flatten

Анализируем и компилируем решение...

Запускаем тесты...

Успех!

```



---



\## Диаграмма вызовов функций (ASCII)



```

v0.exe

&nbsp; ├─ system("g++ ... v1\_main.cpp -> v1.exe")

&nbsp; ├─ system("v1.exe")                     // тесты V1

&nbsp; ├─ system("v1.exe --flatten ...")       // склейка V2

&nbsp; │     └─ v1\_main.cpp: main()

&nbsp; │           └─ FlattenProject(...)

&nbsp; │                 └─ PreprocessOne\_Flatten(...)

&nbsp; │                      ├─ regex\_match("#include \\"...\\"")

&nbsp; │                      └─ рекурсия

&nbsp; ├─ system("g++ ... build/v2\_flat.cpp -> v2.exe")

&nbsp; └─ system("v2.exe")                     // тесты V2

```



---



